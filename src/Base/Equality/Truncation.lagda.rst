.. FILE      : Base/Equality/Truncation.lagda.rst
.. AUTHOR    : William DeMeo
.. DATE      : 23 Feb 2021
.. UPDATED   : 23 Jun 2022

.. highlight:: agda
.. role:: code

.. _base-equality-truncation:

Truncation
~~~~~~~~~~

This is the `Base.Equality.Truncation`_ module of the `Agda Universal Algebra Library`_.

We start with a brief discussion of standard notions of *truncation*, *h-sets*
(which we just call *sets*), and the *uniqueness of identity types* principle.
We then prove that a monic function into a *set* is an embedding. The section
concludes with a *uniqueness of identity proofs* principle for blocks of
equivalence relations.

Readers who want to learn more about "proof-relevant mathematics" and other
concepts mentioned in this module may wish to consult other sources, such as
`Section 34 <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#truncation>`__
and
`35 <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#resizing>`__
of `Mart√≠n Escard√≥'s notes`_, or
`Guillaume Brunerie, Truncations and truncated higher inductive
types <https://homotopytypetheory.org/2012/09/16/truncations-and-truncated-higher-inductive-types/>`__,
or Section 7.1 of the `HoTT book`_.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  module Base.Equality.Truncation where

  -- Imports from Agda and the Agda Standard Library  -------------------------------------
  open import Agda.Primitive   renaming ( Set to Type )                  using ()
  open import Data.Product     renaming ( proj‚ÇÅ to fst ; proj‚ÇÇ to snd )  using ( _,_ ; Œ£ ; Œ£-syntax ; _√ó_ )
  open import Function                                                   using ( _‚àò_ ; id )
  open import Level                                                      using ( _‚äî_ ; suc ; Level )
  open import Relation.Binary  renaming ( Rel to BinRel )                using ( IsEquivalence )
  open import Relation.Binary.PropositionalEquality as ‚â°                 using ( _‚â°_ ; module ‚â°-Reasoning )
  open import Relation.Unary                                             using ( Pred ; _‚äÜ_ )

  -- Imports from the Agda Universal Algebra Library --------------------------------------
  open import Overture         using ( _‚Åª¬π ; transport ; ‚à•_‚à• ; _‚âà_ ; ‚à£_‚à£ )
  open import Base.Functions    using ( IsInjective )
  open import Base.Relations   using ( IsBlock ; Rel ; REL )

  private variable Œ± Œ≤ œÅ ùì• : Level

The MGS-Quotient module of the `Type Topology`_ library defines a *uniqueness-of-proofs*
principle for binary relations. We borrow this and related definitions.

First, a type is a *singleton* if it has exactly one inhabitant and a *subsingleton* if
it has *at most* one inhabitant. Representing these concepts are the following types
(whose original definitions we import from the ``MGS-Basic-UF`` module of `Type Topology`_).

::

  is-center : (A : Type Œ± ) ‚Üí A ‚Üí Type Œ±
  is-center A c = (x : A) ‚Üí c ‚â° x

  is-singleton : Type Œ± ‚Üí Type Œ±
  is-singleton A = Œ£ A (is-center A)

  is-prop : Type Œ± ‚Üí Type Œ±
  is-prop A = (x y : A) ‚Üí x ‚â° y

  is-prop-valued : {A : Type Œ±} ‚Üí BinRel A œÅ ‚Üí Type(Œ± ‚äî œÅ)
  is-prop-valued  _‚âà_ = ‚àÄ x y ‚Üí is-prop (x ‚âà y)

  open ‚â°-Reasoning
  singleton-is-prop : {Œ± : Level}(X : Type Œ±) ‚Üí is-singleton X ‚Üí is-prop X
  singleton-is-prop X (c , œÜ) x y = x ‚â°‚ü® (œÜ x)‚Åª¬π ‚ü© c ‚â°‚ü® œÜ y ‚ü© y ‚àé

The concept of a `fiber <https://ncatlab.org/nlab/show/fiber>`__ of a function is,
in the `Type Topology`_ library, defined as a Sigma type whose inhabitants
represent inverse images of points in the codomain of the given function.

::

  fiber : {A : Type Œ± } {B : Type Œ≤ } (f : A ‚Üí B) ‚Üí B ‚Üí Type (Œ± ‚äî Œ≤)
  fiber {Œ±}{Œ≤}{A} f y = Œ£[ x ‚àà A ] f x ‚â° y

  -- A function is called an *equivalence* if all of its fibers are singletons.
  is-equiv : {A : Type Œ± } {B : Type Œ≤ } ‚Üí (A ‚Üí B) ‚Üí Type (Œ± ‚äî Œ≤)
  is-equiv f = ‚àÄ y ‚Üí is-singleton (fiber f y)

  -- An alternative means of postulating function extensionality.
  hfunext :  ‚àÄ Œ± Œ≤ ‚Üí Type (suc (Œ± ‚äî Œ≤))
  hfunext Œ± Œ≤ = {A : Type Œ±}{B : A ‚Üí Type Œ≤} (f g : (x : A) ‚Üí B x) ‚Üí is-equiv (‚â°.cong-app{f = f}{g})

Thus, if ``R : Rel A Œ≤``, then ``is-subsingleton-valued R`` is the assertion that
for each pair ``x y : A`` there can be at most one proof that ``R x y`` holds.

.. _base-equality-uniqueness-of-identity-proofs:

Uniqueness of identity proofs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This brief introduction is intended for novices; those already familiar with the
concept of *truncation* and *uniqueness of identity proofs* may want to skip to
the next subsection.

In general, we may have many inhabitants of a given type, hence (via Curry-Howard)
many proofs of a given proposition. For instance, suppose we have a type ``A``
and an identity relation ``_‚â°‚ÇÄ_`` on ``A`` so that, given two inhabitants of
``A``, say, ``a b : A``, we can form the type ``a ‚â°‚ÇÄ b``. Suppose ``p`` and
``q`` inhabit the type ``a ‚â°‚ÇÄ b``; that is, ``p`` and ``q`` are proofs of
``a ‚â°‚ÇÄ b``, in which case we write ``p q : a ‚â°‚ÇÄ b``. We might then wonder
whether and in what sense are the two proofs ``p`` and ``q`` the equivalent.

We are asking about an identity type on the identity type ``‚â°‚ÇÄ``, and whether
there is some inhabitant, say, ``r`` of this type; i.e., whether there is a
proof ``r : p ‚â°‚Çì‚ÇÅ q`` that the proofs of ``a ‚â°‚ÇÄ b`` are the same. If such a
proof exists for all ``p q : a ‚â°‚ÇÄ b``, then the proof of ``a ‚â°‚ÇÄ b`` is unique;
as a property of the types ``A`` and ``‚â°‚ÇÄ``, this is sometimes called *uniqueness
of identity proofs* (uip).

Now, perhaps we have two proofs, say, ``r s : p ‚â°‚ÇÅ q`` that the proofs ``p`` and
``q`` are equivalent. Then of course we wonder whether ``r ‚â°‚ÇÇ s`` has a proof!
But at some level we may decide that the potential to distinguish two proofs of
an identity in a meaningful way (so-called *proof-relevance*) is not useful or
desirable. At that point, say, at level ``k``, we would be naturally inclined to
assume that there is at most one proof of any identity of the form ``p ‚â°‚Çñ q``.
This is called
`truncation <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#truncation>`__
(at level ``k``).

.. _base-equality-sets:

Sets
^^^^

In `homotopy type theory <https://homotopytypetheory.org>`__, a type ``A`` with
an identity relation ``‚â°‚ÇÄ`` is called a *set* (or *0-groupoid*) if for every
pair ``x y : A`` there is at most one proof of ``x ‚â°‚ÇÄ y``. In other words, the
type ``A``, along with it's equality type ``‚â°‚ÇÄ``, form a *set* if for all
``x y : A`` there is at most one proof of ``x ‚â°‚ÇÄ y``.

This notion is formalized in the `Type Topology`_ library, using the
``is-subsingleton`` type that we saw earlier (`Base.Functions.Inverses`_), as follows.

::

  is-set : Type Œ± ‚Üí Type Œ±
  is-set A = is-prop-valued{A = A} _‚â°_

Thus, the pair ``(A , ‚â°‚ÇÄ)`` forms a set if and only if it satisfies
``‚àÄ x y : A ‚Üí is-subsingleton (x ‚â°‚ÇÄ y)``.

We will also need the function
`to-Œ£-‚â° <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#sigmaequality>`__,
which is part of Escard√≥'s characterization of *equality in Sigma types*.

::

  module _ {A : Type Œ±}{B : A ‚Üí Type Œ≤} where

   to-Œ£-‚â° : {œÉ œÑ : Œ£[ x ‚àà A ] B x} ‚Üí (Œ£[ p ‚àà (fst œÉ ‚â° fst œÑ) ] (transport B p ‚à• œÉ ‚à•) ‚â° ‚à• œÑ ‚à•) ‚Üí œÉ ‚â° œÑ
   to-Œ£-‚â° (‚â°.refl , ‚â°.refl) = ‚â°.refl

.. _base-equality-embeddings:

Embeddings
^^^^^^^^^^

The ``is-embedding`` type is defined in the ``MGS-Embeddings`` module of the
`Type Topology`_ library in the following way.

::

  is-embedding : {A : Type Œ±}{B : Type Œ≤} ‚Üí (A ‚Üí B) ‚Üí Type (Œ± ‚äî Œ≤)
  is-embedding f = ‚àÄ b ‚Üí is-prop (fiber f b)

  singleton-type : {A : Type Œ±} ‚Üí A ‚Üí Type Œ±
  singleton-type {Œ±}{A} x = Œ£[ y ‚àà A ] y ‚â° x

Thus, ``is-embedding f`` asserts that ``f`` is a function all of whose fibers are
subsingletons. Observe that an embedding is not simply an injective map. However,
if we assume that the codomain ``B`` has *unique identity proofs* (UIP), then we
can prove that a monic function into ``B`` is an embedding. We will do exactly that
in the `Base.Equality.Truncation`_ module when we take up the topic of *sets*
and the UIP.

Finding a proof that a function is an embedding isn‚Äôt always easy, but
one approach that is often fairly straightforward is to first prove that
the function is invertible and then invoke the
``invertible-is-embedding`` theorem from the `Type Topology`_ library.

::

  module _ {A : Type Œ±}{B : Type Œ≤} where

   invertible : (A ‚Üí B) ‚Üí Type (Œ± ‚äî Œ≤)
   invertible f = Œ£[ g ‚àà (B ‚Üí A) ] ((g ‚àò f ‚âà id) √ó (f ‚àò g ‚âà id))

   equiv-is-embedding : (f : A ‚Üí B) ‚Üí is-equiv f ‚Üí is-embedding f
   equiv-is-embedding f i y = singleton-is-prop (fiber f y) (i y)

We will use ``is-embedding``, ``is-set``, and ``to-Œ£-‚â°`` in the next
subsection to prove that a monic function into a set is an embedding.

.. _base-equality-injective-functions-are-set-embeddings:

Injective functions are set embeddings
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Before moving on to define
`propositions <Base.Equality.Truncation.html#general-propositions>`__, we discharge
an obligation we mentioned but left unfulfilled in the
`embeddings <Base.Functions.Inverses.html#embeddings>`__ section of the
`Base.Functions.Inverses`_ module. Recall, we described and imported the
``is-embedding`` type, and we remarked that an embedding is not simply a monic
function. However, if we assume that the codomain is truncated so as to have
unique identity proofs (i.e., is a set), then we can prove that any monic
function into that codomain will be an embedding. On the other hand, embeddings
are always monic, so we will end up with an equivalence.

::

  private variable
   A : Type Œ±
   B : Type Œ≤

  monic-is-embedding|Set : (f : A ‚Üí B) ‚Üí is-set B ‚Üí IsInjective f ‚Üí is-embedding f
  monic-is-embedding|Set f Bset fmon b (u , fu‚â°b) (v , fv‚â°b) = Œ≥
   where
   fuv : f u ‚â° f v
   fuv = ‚â°.trans fu‚â°b (fv‚â°b ‚Åª¬π)

   uv : u ‚â° v
   uv = fmon fuv

   arg1 : Œ£[ p ‚àà u ‚â° v ] transport (Œª a ‚Üí f a ‚â° b) p fu‚â°b ‚â° fv‚â°b
   arg1 = uv , Bset (f v) b (transport (Œª a ‚Üí f a ‚â° b) uv fu‚â°b) fv‚â°b

   Œ≥ : (u , fu‚â°b) ‚â° (v , fv‚â°b)
   Œ≥ = to-Œ£-‚â° arg1

In stating the previous result, we introduce a new convention to which we will
try to adhere. If the antecedent of a theorem includes the assumption that one
of the types involved is a *set* (in the sense defined above), then we add to
the name of the theorem the suffix ``|Set``, which calls to mind the standard
mathematical notation for the restriction of a function.

.. _base-equality-equivalence-class-truncation:

Equivalence class truncation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recall, ``IsBlock`` was defined in the `Base.Relations.Quotients`_ module as follows:

.. code:: agda

   IsBlock : {A : Type Œ±}(C : Pred A Œ≤){R : Rel A Œ≤} ‚Üí Type(Œ± ‚äî lsuc Œ≤)
   IsBlock {A} C {R} = Œ£ u Íûâ A , C ‚â° [ u ] {R}

In the next module we will define a *quotient extensionality* principle that will
require a form of unique identity proofs‚Äîspecifically, we will assume that for
each predicate ``C : Pred A Œ≤`` there is at most one proof of ``IsBlock C``.
We call this proof-irrelevance principle "uniqueness of block identity proofs",
and define it as follows.

::

  blk-uip : (A : Type Œ±)(R : BinRel A œÅ ) ‚Üí Type(Œ± ‚äî suc œÅ)
  blk-uip A R = ‚àÄ (C : Pred A _) ‚Üí is-prop (IsBlock C {R})

It might seem unreasonable to postulate that there is at most one inhabitant of
``IsBlock C``, since equivalence classes typically have multiple members, any
one of which could serve as a class representative. However, postulating
``blk-uip A R`` is tantamount to collapsing each ``R``-block to a single point,
and this is indeed the correct semantic interpretation of the elements of the
quotient ``A / R``.

.. _base-equality-general-propositions:

General propositions
^^^^^^^^^^^^^^^^^^^^

This section defines more general truncated predicates which we call *continuous
propositions* and *dependent propositions*. Recall, above (in the
`Base.Relations.Continuous`_ module) we defined types called ``Rel`` and ``REL``
to represent relations of arbitrary arity over arbitrary collections of sorts.

Naturally, we define the corresponding *truncated continuous relation type* and
*truncated dependent relation type*, the inhabitants of which we will call
*continuous propositions* and *dependent propositions*, respectively.

::

  module _ {I : Type ùì•} where

   IsRelProp : {œÅ : Level}(A : Type Œ±) ‚Üí Rel A I{œÅ} ‚Üí Type (ùì• ‚äî Œ± ‚äî œÅ)
   IsRelProp B P = ‚àÄ (b : (I ‚Üí B)) ‚Üí is-prop (P b)

   RelProp : Type Œ± ‚Üí (œÅ : Level) ‚Üí Type (ùì• ‚äî Œ± ‚äî suc œÅ)
   RelProp A œÅ = Œ£[ P ‚àà Rel A I{œÅ} ] IsRelProp A P

   RelPropExt : Type Œ± ‚Üí (œÅ : Level) ‚Üí Type (ùì• ‚äî Œ± ‚äî suc œÅ)
   RelPropExt A œÅ = {P Q : RelProp A œÅ } ‚Üí ‚à£ P ‚à£ ‚äÜ ‚à£ Q ‚à£ ‚Üí ‚à£ Q ‚à£ ‚äÜ ‚à£ P ‚à£ ‚Üí P ‚â° Q

   IsRELProp : {œÅ : Level} (ùíú : I ‚Üí Type Œ±) ‚Üí REL I ùíú {œÅ}  ‚Üí Type (ùì• ‚äî Œ± ‚äî œÅ)
   IsRELProp ùíú P = ‚àÄ (a : ((i : I) ‚Üí ùíú i)) ‚Üí is-prop (P a)

   RELProp : (I ‚Üí Type Œ±) ‚Üí (œÅ : Level) ‚Üí Type (ùì• ‚äî Œ± ‚äî suc œÅ)
   RELProp ùíú œÅ = Œ£[ P ‚àà REL I ùíú {œÅ} ] IsRELProp ùíú P

   RELPropExt : (I ‚Üí Type Œ±) ‚Üí (œÅ : Level) ‚Üí Type (ùì• ‚äî Œ± ‚äî suc œÅ)
   RELPropExt ùíú œÅ = {P Q : RELProp ùíú œÅ} ‚Üí ‚à£ P ‚à£ ‚äÜ ‚à£ Q ‚à£ ‚Üí ‚à£ Q ‚à£ ‚äÜ ‚à£ P ‚à£ ‚Üí P ‚â° Q

