.. FILE      : Base/Subalgebras/Subuniverses.lagda.rst
.. AUTHOR    : William DeMeo
.. DATE      : 14 Jan 2021
.. UPDATED   : 23 Jun 2022

.. highlight:: agda
.. role:: code

.. _base-subalgebras-subuniverses:

Subuniverses
~~~~~~~~~~~~

This is the `Base.Subalgebras.Subuniverses`_ module of the `Agda Universal Algebra Library`_.

We start by defining a type that represents the important concept of
*subuniverse*. Suppose ``ğ‘¨`` is an algebra. A subset ``B âŠ† âˆ£ ğ‘¨ âˆ£`` is said to be
*closed under the operations of* ``ğ‘¨`` if for each ``ğ‘“ âˆˆ âˆ£ ğ‘† âˆ£`` and all tuples
``ğ’ƒ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ ğµ`` the element ``(ğ‘“ Ì‚ ğ‘¨) ğ’ƒ`` belongs to ``B``. If a subset
``B âŠ† ğ´`` is closed under the operations of ``ğ‘¨``, then we call B a *subuniverse*
of ``ğ‘¨``.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import Overture using ( ğ“ ; ğ“¥ ; Signature )

  module Base.Subalgebras.Subuniverses {ğ‘† : Signature ğ“ ğ“¥} where

  -- Imports from Agda and the Agda Standard Library -----------------------------
  open import Agda.Primitive       using () renaming ( Set to Type )
  open import Function             using ( _âˆ˜_ )
  open import Level                using ( Level ; _âŠ”_ )
  open import Relation.Unary       using ( Pred ; _âˆˆ_ ; _âŠ†_ ; â‹‚ )
  open import Axiom.Extensionality.Propositional
                                   using () renaming ( Extensionality to funext )
  open import Relation.Binary.PropositionalEquality
                                   using ( module â‰¡-Reasoning ; _â‰¡_ )

  -- Imports from the Agda Universal Algebra Library -----------------------------
  open import Overture                     using ( âˆ£_âˆ£ ; âˆ¥_âˆ¥ ; _â»Â¹ )
  open import Base.Relations               using ( Im_âŠ†_ )
  open import Base.Equality                using ( swelldef )
  open import Base.Algebras       {ğ‘† = ğ‘†}  using ( Algebra ; _Ì‚_ ; ov )
  open import Base.Homomorphisms  {ğ‘† = ğ‘†}  using ( hom )
  open import Base.Terms          {ğ‘† = ğ‘†}  using ( Term ; â„Š ; node ; _âŸ¦_âŸ§ )

  private variable Î± Î² ğ“§ : Level

We first show how to represent in Agda_ the collection of subuniverses of an
algebra ``ğ‘¨``. Since a subuniverse is viewed as a subset of the domain of ``ğ‘¨``,
we define it as a predicate on ``âˆ£ ğ‘¨ âˆ£``. Thus, the collection of subuniverses is
a predicate on predicates on ``âˆ£ ğ‘¨ âˆ£``.

::

  Subuniverses : (ğ‘¨ : Algebra Î±) â†’ Pred (Pred âˆ£ ğ‘¨ âˆ£ Î²) (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)
  Subuniverses ğ‘¨ B = (ğ‘“ : âˆ£ ğ‘† âˆ£)(ğ‘ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£) â†’ Im ğ‘ âŠ† B â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ B

.. _base-subalgebras-subuniverses-as-records:

Subuniverses as records
^^^^^^^^^^^^^^^^^^^^^^^

Next we define a type to represent a single subuniverse of an algebra. If ``ğ‘¨`` is
the algebra in question, then a subuniverse of ``ğ‘¨`` is a subset of (i.e.,
predicate over) the domain ``âˆ£ ğ‘¨ âˆ£`` that belongs to ``Subuniverses ğ‘¨``.

::

  record Subuniverse {ğ‘¨ : Algebra Î±} : Type(ov Î² âŠ” Î±) where
   constructor mksub
   field
    sset  : Pred âˆ£ ğ‘¨ âˆ£ Î²
    sSub : sset âˆˆ Subuniverses ğ‘¨


.. _base-subalgebras-subuniverse-generation:

Subuniverse Generation
^^^^^^^^^^^^^^^^^^^^^^

If ``ğ‘¨`` is an algebra and ``X âŠ† âˆ£ ğ‘¨ âˆ£`` a subset of the domain of ``ğ‘¨``, then the
*subuniverse of* ``ğ‘¨`` *generated by* ``X`` is typically denoted by ``Sg ğ‘¨ (X)``
and defined to be the smallest subuniverse of ``ğ‘¨`` containing ``X``.
Equivalently, ``Sg ğ‘¨ (X) = â‹‚ { U : U`` is a subuniverse of ``ğ‘¨`` and ``B âŠ† U }``.

We define an inductive type, denoted by ``Sg``, that represents the subuniverse
generated by a given subset of the domain of a given algebra, as follows.

::

  data Sg (ğ‘¨ : Algebra Î±)(X : Pred âˆ£ ğ‘¨ âˆ£ Î²) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)
   where
   var : âˆ€ {v} â†’ v âˆˆ X â†’ v âˆˆ Sg ğ‘¨ X
   app : âˆ€ f a â†’ Im a âŠ† Sg ğ‘¨ X â†’ (f Ì‚ ğ‘¨) a âˆˆ Sg ğ‘¨ X

(The inferred types in the ``app`` constructor are ``f : âˆ£ ğ‘† âˆ£`` and ``a : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£``.)

Given an arbitrary subset ``X`` of the domain ``âˆ£ ğ‘¨ âˆ£`` of an ``ğ‘†``-algebra ``ğ‘¨``,
the type ``Sg X`` does indeed represent a subuniverse of ``ğ‘¨``. Proving this using
the inductive type ``Sg`` is trivial, as we see here.

::

  sgIsSub : {ğ‘¨ : Algebra Î±}{X : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ Sg ğ‘¨ X âˆˆ Subuniverses ğ‘¨
  sgIsSub = app

Next we prove by structural induction that ``Sg X`` is the smallest subuniverse of
``ğ‘¨`` containing ``X``.

::

  sgIsSmallest :  {ğ“¡ : Level}(ğ‘¨ : Algebra Î±){X : Pred âˆ£ ğ‘¨ âˆ£ Î²}(Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¡)
   â†’              Y âˆˆ Subuniverses ğ‘¨  â†’  X âŠ† Y  â†’  Sg ğ‘¨ X âŠ† Y

  sgIsSmallest _ _ _ XinY (var Xv) = XinY Xv
  sgIsSmallest ğ‘¨ Y YsubA XinY (app f a SgXa) = Yfa
   where
   IH : Im a âŠ† Y
   IH i = sgIsSmallest ğ‘¨ Y YsubA XinY (SgXa i)

   Yfa : (f Ì‚ ğ‘¨) a âˆˆ Y
   Yfa = YsubA f a IH

When the element of ``Sg X`` is constructed as ``app f a SgXa``, we may assume
(the induction hypothesis) that the arguments in the tuple ``a`` belong to ``Y``.
Then the result of applying ``f`` to ``a`` also belongs to ``Y`` since ``Y`` is a
subuniverse.

.. _base-subalgebras-subuniverse-lemmas:

Subuniverse Lemmas
^^^^^^^^^^^^^^^^^^

Here we formalize a few basic properties of subuniverses. First, the intersection
of subuniverses is again a subuniverse. 

::

  â‹‚s :  {ğ“˜ : Level}{ğ‘¨ : Algebra Î±}{I : Type ğ“˜}{ğ’œ : I â†’ Pred âˆ£ ğ‘¨ âˆ£ Î²}
   â†’    (âˆ€ i â†’ ğ’œ i âˆˆ Subuniverses ğ‘¨) â†’ â‹‚ I ğ’œ âˆˆ Subuniverses ğ‘¨

  â‹‚s Ïƒ f a Î½ = Î» i â†’ Ïƒ i f a (Î» x â†’ Î½ x i)


In the proof above, we assume the following typing judgments:

.. code:: agda

   Ïƒ : âˆ€ i â†’ ğ’œ i âˆˆ Subuniverses ğ‘¨
   f : âˆ£ ğ‘† âˆ£
   a : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
   Î½ : Im ğ‘ âŠ† â‹‚ I ğ’œ

and we must prove ``(f Ì‚ ğ‘¨) a âˆˆ â‹‚ I ğ’œ``. In this case, Agda will fill in the proof
term ``Î» i â†’ Ïƒ i f a (Î» x â†’ Î½ x i)`` automatically with the command ``C-c C-a``.

Next, subuniverses are closed under the action of term operations.

::

  sub-term-closed :  {ğ“§ : Level}{X : Type ğ“§}(ğ‘¨ : Algebra Î±){B : Pred âˆ£ ğ‘¨ âˆ£ Î²}
   â†’                 (B âˆˆ Subuniverses ğ‘¨) â†’ (t : Term X)(b : X â†’ âˆ£ ğ‘¨ âˆ£)
   â†’                 ((x : X) â†’ (b x âˆˆ B)) â†’ (ğ‘¨ âŸ¦ t âŸ§)b âˆˆ B

  sub-term-closed ğ‘¨ AB (â„Š x) b Bb = Bb x

  sub-term-closed ğ‘¨{B} Ïƒ (node f t)b Î½ =
   Ïƒ f  (Î» z â†’ (ğ‘¨ âŸ¦ t z âŸ§) b) Î» x â†’ sub-term-closed ğ‘¨{B} Ïƒ (t x) b Î½

In the induction step of the foregoing proof, the typing judgments of the premise
are the following:

.. code:: agda

   ğ‘¨   : Algebra Î± ğ‘†
   B   : Pred âˆ£ ğ‘¨ âˆ£ Î²
   Ïƒ   : B âˆˆ Subuniverses ğ‘¨
   f   : âˆ£ ğ‘† âˆ£
   t   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ Term X
   b   : X â†’ âˆ£ ğ‘¨ âˆ£
   Î½   : âˆ€ x â†’ b x âˆˆ B

and the given proof term establishes the goal ``ğ‘¨ âŸ¦ node f t âŸ§ b âˆˆ B``.

Alternatively, we could express the preceeding fact using an inductive type
representing images of terms.

::

  data TermImage (ğ‘¨ : Algebra Î±)(Y : Pred âˆ£ ğ‘¨ âˆ£ Î²) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)
   where
   var : âˆ€ {y : âˆ£ ğ‘¨ âˆ£} â†’ y âˆˆ Y â†’ y âˆˆ TermImage ğ‘¨ Y
   app : âˆ€ ğ‘“ ğ‘¡ â†’  ((x : âˆ¥ ğ‘† âˆ¥ ğ‘“) â†’ ğ‘¡ x âˆˆ TermImage ğ‘¨ Y)  â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘¡ âˆˆ TermImage ğ‘¨ Y

By what we proved above, it should come as no surprise that ``TermImage ğ‘¨ Y`` is a
subuniverse of ``ğ‘¨`` that contains ``Y``.

::

  TermImageIsSub : {ğ‘¨ : Algebra Î±}{Y : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ TermImage ğ‘¨ Y âˆˆ Subuniverses ğ‘¨
  TermImageIsSub = app

  Y-onlyif-TermImageY : {ğ‘¨ : Algebra Î±}{Y : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ Y âŠ† TermImage ğ‘¨ Y
  Y-onlyif-TermImageY {a} Ya = var Ya

Since ``Sg ğ‘¨ Y`` is the smallest subuniverse containing Y, we obtain the following inclusion.

::

  SgY-onlyif-TermImageY : (ğ‘¨ : Algebra Î±)(Y : Pred âˆ£ ğ‘¨ âˆ£ Î²) â†’ Sg ğ‘¨ Y âŠ† TermImage ğ‘¨ Y
  SgY-onlyif-TermImageY ğ‘¨ Y = sgIsSmallest ğ‘¨ (TermImage ğ‘¨ Y) TermImageIsSub Y-onlyif-TermImageY

Next we prove the important fact that homomorphisms are uniquely determined by
their values on a generating set.

::

  open â‰¡-Reasoning

  hom-unique :  swelldef ğ“¥ Î² â†’ {ğ‘¨ : Algebra Î±}{ğ‘© : Algebra Î²}
                (X : Pred âˆ£ ğ‘¨ âˆ£ Î±)  (g h : hom ğ‘¨ ğ‘©)
   â†’            ((x : âˆ£ ğ‘¨ âˆ£) â†’ (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x))
                -----------------------------------------------
   â†’            (a : âˆ£ ğ‘¨ âˆ£) â†’ (a âˆˆ Sg ğ‘¨ X â†’ âˆ£ g âˆ£ a â‰¡ âˆ£ h âˆ£ a)

  hom-unique _ _ _ _ Ïƒ a (var x) = Ïƒ a x

  hom-unique wd {ğ‘¨}{ğ‘©} X g h Ïƒ fa (app ğ‘“ a Î½) = Goal
   where
   IH : âˆ€ x â†’ âˆ£ g âˆ£ (a x) â‰¡ âˆ£ h âˆ£ (a x)
   IH x = hom-unique wd{ğ‘¨}{ğ‘©} X g h Ïƒ (a x) (Î½ x)

   Goal : âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a) â‰¡ âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)
   Goal =  âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)    â‰¡âŸ¨ âˆ¥ g âˆ¥ ğ‘“ a âŸ©
           (ğ‘“ Ì‚ ğ‘©)(âˆ£ g âˆ£ âˆ˜ a )  â‰¡âŸ¨ wd (ğ‘“ Ì‚ ğ‘©) (âˆ£ g âˆ£ âˆ˜ a) (âˆ£ h âˆ£ âˆ˜ a) IH âŸ©
           (ğ‘“ Ì‚ ğ‘©)(âˆ£ h âˆ£ âˆ˜ a)   â‰¡âŸ¨ ( âˆ¥ h âˆ¥ ğ‘“ a )â»Â¹ âŸ©
           âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a )   âˆ

In the induction step, the following typing judgments are assumed:

.. code:: agda

   wd  : swelldef ğ“¥ Î²
   ğ‘¨   : Algebra Î± ğ‘†
   ğ‘©   : Algebra Î² ğ‘†
   X   : Pred âˆ£ ğ‘¨ âˆ£ Î±
   g h  : hom ğ‘¨ ğ‘©
   Ïƒ   : Î  x ê‰ âˆ£ ğ‘¨ âˆ£ , (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x)
   fa  : âˆ£ ğ‘¨ âˆ£
   fa  = (ğ‘“ Ì‚ ğ‘¨) a
   ğ‘“   : âˆ£ ğ‘† âˆ£
   a   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
   Î½   : Im a âŠ† Sg ğ‘¨ X

and, under these assumptions, we proved ``âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a) â‰¡ âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)``.


